@page "/"  
@using System.ComponentModel  
@inject IChatClient ChatClient  
@inject NavigationManager Nav  
@inject SemanticSearch Search  
@inject AspireAIAgentsCSVSChat.Web.Services.MultiAgents.MultiAgentApiClient MultiAgentApiClient
@implements IDisposable  
@using Microsoft.AspNetCore.Hosting
@using AspireAIAgentsCSVSChat.Web.Services.Ingestion
@using Microsoft.SemanticKernel
@using Microsoft.KernelMemory
@using Microsoft.KernelMemory.AI
@using Microsoft.KernelMemory.MemoryStorage.DevTools
@using System.Diagnostics
@using UglyToad.PdfPig
@inject IServiceProvider ServiceProvider

<PageTitle>Chat</PageTitle>  

<ChatHeader OnNewChat="@ResetConversationAsync" />  

<ChatMessageList Messages="@messages" InProgressMessage="@currentResponseMessage">  
    <NoMessagesContent>  
        <div>To get started, try asking about these example documents. You can replace these with your own data and replace this message.</div>
        <ChatCitation File="GMP_Compliance_Report_Guidelines_V_7.pdf"/>
    </NoMessagesContent>  
</ChatMessageList>  

<div class="chat-container">  
    <ChatSuggestions OnSelected="@AddUserMessageAsync" @ref="@chatSuggestions" />  
    <ChatInput OnSend="@AddUserMessageAsync" @ref="@chatInput" />  
    @* <SurveyPrompt /> *@ @* Remove this line to eliminate the template survey message *@ 

    <div class="btn-default upload-button" style="width:250px; margin:10px; margin-left:95px;">  
        <InputFile OnChange="UploadFileSelected" />  
    </div>  
</div>  

@code {
    private IHostingEnvironment _environment;

    private async Task UploadFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File as IBrowserFile;
        if (file is not null)  
        {  
            var uploadPath = Path.Combine("wwwroot", "Uploads", file.Name);  
            Directory.CreateDirectory(Path.GetDirectoryName(uploadPath)!);  

            await using var stream = file.OpenReadStream();  
            await using var fileStream = File.Create(uploadPath);  
            await stream.CopyToAsync(fileStream);  

            await fileStream.DisposeAsync();  
            await stream.DisposeAsync();  

            _environment = ServiceProvider.GetRequiredService<IHostingEnvironment>();  
            await DataIngestor.IngestDataAsync(  
                ServiceProvider,  
                new PDFDirectorySource(Path.Combine(_environment.WebRootPath, "Uploads"))  
            );  
        }
    }
}

@code {
    private const string SystemPrompt = @"  
       You are an CSV assistant who answers questions about information you retrieve.
       Use only simple markdown to format your responses.
       If user types in @process, you will run SearchMultiAgentAsync, and if user types in @memory, you will run SearchMemoryAsync otherwise run SearchAsync.
       You are able to fully check or analyze whole external documents and process them if you can to see if this document is compliant or not.
       You can analyse any provided snippets or key sections of the report
       Do not answer questions about anything else.  

       You can use the search tool to find relevant information. When you do this, end your  
       reply with any citations as the source in the special XML format:  

       <citation filename='string' page_number='number'>exact quote here</citation>  

       Always include the citation in your response if there are results.   
       ";  

    OpenAIConfig openAIConfig = new OpenAIConfig();
    AzureOpenAIConfig azureOpenAITextConfig = new AzureOpenAIConfig();
    AzureOpenAIConfig azureOpenAIEmbeddingConfig = new AzureOpenAIConfig();


    private readonly ChatOptions chatOptions = new();  
    private readonly List<ChatMessage> messages = new();  
    private CancellationTokenSource? currentResponseCancellation;  
    private ChatMessage? currentResponseMessage;  
    private ChatInput? chatInput;  
    private ChatSuggestions? chatSuggestions;
    private ChatMessage? _userMessage;

    protected override void OnInitialized()  
       {  
           messages.Add(new(ChatRole.System, SystemPrompt));  
           chatOptions.Tools = [AIFunctionFactory.Create(SearchAsync),
                                AIFunctionFactory.Create(SearchMultiAgentAsync),
                                AIFunctionFactory.Create(SearchMemoryAsync)];

           // azureOpenAIEmbeddingConfig.Endpoint = "https://team-cnca.openai.azure.com/";
           // azureOpenAIEmbeddingConfig.APIKey = "9sRuOPjJkuPOQ6JjmXi7HAymODjcZnlHxfuhHz9vgij6DcpFfE9hJQQJ99BDACmepeSXJ3w3AAABACOGJi2N";
           // azureOpenAIEmbeddingConfig.Deployment = "gpt-4o-mini";

           var embeddingGenerator = ServiceProvider.GetService<ITextEmbeddingGenerator>();

           if (embeddingGenerator == null)
           {
               throw new InvalidOperationException("ITextEmbeddingGenerator was not registered properly.");
           }

           var kernel = Kernel.CreateBuilder()
               .Build();

           // var memory = new KernelMemoryBuilder()
           //     .AddIngestionEmbeddingGenerator(embeddingGenerator)
           //     .WithoutDefaultHandlers()
           //     .WithCustomPromptProvider(new CSVSPromptBuilder())
           //     .WithSimpleVectorDb()
           //     //.WithOpenAIDefaults(Environment.GetEnvironmentVariable("AzureOpenAI_ApiKey"))
           //     // .WithOpenAI(openAICfg)
           //     // .WithAzureOpenAITextGeneration(azureOpenAITextConfig)
           //     //.WithAzureOpenAITextEmbeddingGeneration(azureOpenAIEmbeddingConfig)
           //     .Build<MemoryServerless>();

           // memory.ImportDocumentAsync("file5-NASA-news.pdf");

       }

    private async Task AddUserMessageAsync(ChatMessage userMessage)  
    {
        // Assign the user message to the _userMessage field for later use
        _userMessage = userMessage;
        CancelAnyCurrentResponse();  

        // Add the user message to the conversation  
        messages.Add(userMessage);  
        chatSuggestions?.Clear();  
        await chatInput!.FocusAsync();  

        // Stream and display a new response from the IChatClient  
        var responseText = new Microsoft.Extensions.AI.TextContent("");
        currentResponseMessage = new ChatMessage(ChatRole.Assistant, [responseText]);  
        currentResponseCancellation = new();  

        try
        {
            await foreach (var update in ChatClient.GetStreamingResponseAsync([.. messages], chatOptions, currentResponseCancellation.Token))
            {
                messages.AddMessages(update, filter: c => c is not Microsoft.Extensions.AI.TextContent);
                responseText.Text += update.Text;
                ChatMessageItem.NotifyChanged(currentResponseMessage);
            }
        }
        catch (OperationCanceledException)
        {
            // Handle cancellation gracefully
            Console.WriteLine("Streaming response was canceled.");
        }
        catch (Exception ex)
        {
            // Log or handle other exceptions
            Console.WriteLine($"An error occurred: {ex.Message}");
        }

        // Store the final response in the conversation, and begin getting suggestions
        messages.Add(currentResponseMessage!);
        currentResponseMessage = null;
        chatSuggestions?.Update(messages);
    }  

    private void CancelAnyCurrentResponse()  
    {  
        // If a response was cancelled while streaming, include it in the conversation so it's not lost  
        if (currentResponseMessage is not null)  
        {  
            messages.Add(currentResponseMessage);  
        }  

        currentResponseCancellation?.Cancel();  
        currentResponseMessage = null;  
    }  

    private async Task ResetConversationAsync()  
    {  
        CancelAnyCurrentResponse();  
        messages.Clear();  
        messages.Add(new(ChatRole.System, SystemPrompt));  
        chatSuggestions?.Clear();  
        await chatInput!.FocusAsync();  
    }  

    [Description("Searches and informs about information using a phrase or keyword or an existing file")]  
    private async Task<IEnumerable<string>> SearchAsync(  
        [Description("The phrase to search for.")] string searchPhrase,  
        [Description("If possible, specify the filename to search that file only. If not provided or empty, the search includes all files.")] string? filenameFilter = null)  
    {  
        await InvokeAsync(StateHasChanged);  
        var results = await Search.SearchAsync(searchPhrase, filenameFilter, maxResults: 5);  
        return results.Select(result =>  
            $"<result filename=\"{result.FileName}\" page_number=\"{result.PageNumber}\">{result.Text}</result>");  
    }  

    [Description("When user types in command @process, run the multiagent services to validate an input")]
    private async Task<IEnumerable<string>> SearchMultiAgentAsync(
       [Description("If possible, specify the filename to process that file only. If not provided or empty, the search includes all files.")] string? filenameFilter = null)
    {
        await InvokeAsync(StateHasChanged);

        // Call the GetMultiAgentResponseAsync method
        string aiMultiAgentResponses = await MultiAgentApiClient.GetMultiAgentResponseAsync(_userMessage.Contents.Last().ToString());
        var message = new ChatMessage(ChatRole.Assistant, new Microsoft.Extensions.AI.TextContent(aiMultiAgentResponses).Text);
        messages.Add(message);
        ChatMessageItem.NotifyChanged(message);

        var results = message;

        // Convert the string into a single-element IEnumerable
        IEnumerable<string> result = new List<string> { aiMultiAgentResponses };

        // // Combine the multi-agent response with search results
        // IEnumerable<string> combinedResults = searchResults.Aggregate(aiMultiAgentResponses);

        // Wrap the IEnumerable in a Task
        return await Task.FromResult(result);
        // return results.Select(result =>
        //     $"<result filename=\"{result.FileName}\" page_number=\"{result.PageNumber}\">{result.Text}</result>");
    }

    [Description("When user types in command @memory, run the memory vector search services to validate an input")]
    private async Task<IEnumerable<string>> SearchMemoryAsync(
       [Description("The question query to search for.")] string question,  
             [Description("If possible, specify the query to process the memory vector search. If not provided or empty, the query is just do a general query.")] string? filenameFilter = null)  
          {  
              await InvokeAsync(StateHasChanged);  

              // Call the Search Memory Vector method  

              MemoryVectorSearch memoryVectorSearch = new MemoryVectorSearch();  
              var kernel = Kernel.CreateBuilder().Build();  

              await memoryVectorSearch.IngestDataIntoInMemoryVectorStoreAsync(kernel, ServiceProvider);  

              var result = await memoryVectorSearch.SearchAnInMemoryVectorStoreAsync(ServiceProvider, question);  

              // Wrap the result in an IEnumerable<string>  
              return new List<string> { result };  
              // return results.Select(result =>  
              //     $"<result filename=\"{result.FileName}\" page_number=\"{result.PageNumber}\">{result.Text}</result>");  
          }

    public void Dispose()  
        => currentResponseCancellation?.Cancel();



}
